package main

import (
	"container/list"
	"strings"
)

/**
https://leetcode.com/problems/number-of-islands/
*/
type Position struct {
	i int
	j int
}

func numIslands(grid [][]byte) int {
	if len(grid) == 0 {
		return 0
	}
	result := 0
	i := 0
	j := 0
	for ; i < len(grid); i++ {
		for j = 0; j < len(grid[i]); j++ {
			if grid[i][j] == '1' {
				result++
				value := Position{i, j}
				queue := list.New()
				queue.PushBack(value)
				set := make(map[string]int)
				for queue.Len() != 0 {
					node := queue.Front().Value.(Position)
					queue.Remove(queue.Front())
					insert := list.New()
					if node.i+1 < len(grid) && '1' == grid[node.i+1][node.j] {
						value := Position{node.i + 1, node.j}
						insert.PushBack(value)
					}
					if node.j+1 < len(grid[node.i]) && '1' == grid[node.i][node.j+1] {
						value := Position{node.i, node.j + 1}
						insert.PushBack(value)
					}
					if node.i-1 >= 0 && '1' == grid[node.i-1][node.j] {
						value := Position{node.i - 1, node.j}
						insert.PushBack(value)
					}
					if node.j-1 >= 0 && '1' == grid[node.i][node.j-1] {
						value := Position{node.i, node.j - 1}
						insert.PushBack(value)
					}
					for e := insert.Front(); e != nil; e = e.Next() {
						key := strings.Join([]string{string(e.Value.(Position).i + 1), string(e.Value.(Position).j)}, ",")
						if _, ok := set[key]; ok {
							continue
						} else {
							queue.PushBack(e.Value.(Position))
							set[key] = 0
						}
					}
					grid[node.i][node.j] = '0'
				}
				i = 0
			}
		}
	}
	return result
}

func main() {
	println(numIslands([][]byte{{'0', '1', '1', '1', '0'}, {'1', '1', '0', '1', '0'}, {'1', '1', '0', '0', '0'}, {'0', '0', '0', '0', '0'}}))
	println(numIslands([][]byte{{'1', '1', '0', '0', '0'}, {'1', '1', '0', '0', '0'}, {'0', '0', '1', '0', '0'}, {'0', '0', '0', '1', '1'}}))
	println(numIslands([][]byte{{'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '0', '1', '1'}, {'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0'}, {'1', '0', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}, {'1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}, {'1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}, {'1', '0', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1'}, {'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1', '1'}, {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1'}, {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1'}, {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}, {'0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}, {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}, {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}, {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'}, {'1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1', '1'}, {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '0'}, {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0'}, {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}, {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}, {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}}))
}
