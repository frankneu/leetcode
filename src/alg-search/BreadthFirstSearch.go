package main

/**
示例图
0:1,2
1:3
3:4
*/

/**
广度优先搜索基本逻辑
对每个节点都标记颜色，白色——没有被访问过；灰色——被访问过，不保证子节点都被访问过；黑色——被访问过，子节点也都被访问过
1.假设我们以顶点0为原点进行搜索，首先确定邻接0的顶点集合S0 = {1，2}。
2.然后确定顶点1的集合S1 = {3}，顶点2没有邻接点，所以集合为空。
3.然后确定3的邻接点集合S3，因为2已经被遍历过，所以不考虑，所以由顶点3知道的邻接点集合S3 = {4}。
4.然后再确定顶点4的邻接点集合,顶点4没有更多的邻接点了，此时也没有还未遍历的邻接点集合，搜索终止。

BFS()
{
  输入起始点；
  初始化所有顶点标记为未遍历；
  初始化一个队列queue并将起始点放入队列；
  while（queue不为空）
  {
    从队列中删除一个顶点s并标记为已遍历；
    将s邻接的所有还没遍历的点加入队列；
  }
}
*/

type GraphNode struct {
	node  int
	color int
}

func bredthFirstSearch() {

}
